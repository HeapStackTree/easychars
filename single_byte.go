package easychars

import (
	"golang.org/x/text/transform"
)

type iso_8859_1_Decoder struct {
	// transform.NopResetter can be embedded by implementations of Transformer to add a nop Reset method.
	transform.NopResetter
}

func (d iso_8859_1_Decoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
	for _, b := range src {
		if b <= 0x7F {
			if nDst+1 > len(dst) {
				err = transform.ErrShortDst
				return
			}
			dst[nDst] = b
			nDst += 1
		} else {
			if nDst+2 > len(dst) {
				err = transform.ErrShortDst
				return
			}
			dst[nDst] = 0xC0 | b>>6
			dst[nDst+1] = 0x80 | (b & 0x3F)
			nDst += 2
		}
		nSrc += 1
	}
	return
}

type windows_1251_Decoder struct {
	// transform.NopResetter can be embedded by implementations of Transformer to add a nop Reset method.
	transform.NopResetter
}

// convert Windows-1251(byte no less than 0X80 and not equal to 0X98(unused in Windows-1251)) code to correspond Unicode
var charMap_windows_1251 = [128]rune{
	0x0402, 0x0403, 0x0082, 0x0453, 0x0084, 0x0085, 0x0086, 0x0087,
	0x20AC, 0x0089, 0x0409, 0x008B, 0x040A, 0x040C, 0x040B, 0x040F,
	0x0452, 0x0091, 0x0092, 0x0093, 0x0094, 0x0095, 0x0096, 0x0097,
	0x0000, 0x0099, 0x0459, 0x009B, 0x045A, 0x045C, 0x045B, 0x045F,
	0x00A0, 0x040E, 0x045E, 0x0408, 0x00A4, 0x0490, 0x00A6, 0x00A7,
	0x0401, 0x00A9, 0x0404, 0x00AB, 0x00AC, 0x00AD, 0x00AE, 0x0407,
	0x00B0, 0x00B1, 0x0406, 0x0456, 0x0491, 0x00B5, 0x00B6, 0x00B7,
	0x0451, 0x2116, 0x0454, 0x00BB, 0x0458, 0x0405, 0x0455, 0x0457,
	0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0416, 0x0417,
	0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E, 0x041F,
	0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426, 0x0427,
	0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E, 0x042F,
	0x0430, 0x0431, 0x0432, 0x0433, 0x0434, 0x0435, 0x0436, 0x0437,
	0x0438, 0x0439, 0x043A, 0x043B, 0x043C, 0x043D, 0x043E, 0x043F,
	0x0440, 0x0441, 0x0442, 0x0443, 0x0444, 0x0445, 0x0446, 0x0447,
	0x0448, 0x0449, 0x044A, 0x044B, 0x044C, 0x044D, 0x044E, 0x044F,
}

func (d windows_1251_Decoder) Transform(dst, src []byte, atEOF bool) (nDst, nSrc int, err error) {
	var r rune
	for _, b := range src {
		if b <= 0x7F {
			if nDst+1 > len(dst) {
				err = transform.ErrShortDst
				return
			}
			dst[nDst] = b
			nDst += 1
		} else {
			r = charMap_windows_1251[b-0x80]
			utf8codes := unicodeRuneToUtf8(r)
			if nDst+len(utf8codes) > len(dst) {
				err = transform.ErrShortDst
				return
			}
			for i, c := range utf8codes {
				dst[nDst+i] = c
			}
			nDst += len(utf8codes)
		}
		nSrc += 1
	}
	return
}
